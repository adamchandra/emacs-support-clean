package edu.umass.cs.iesl.scalacommons

trait ConfigUtils {

  // import cc.rexa2.commons.{Props => P, PropertyInterpolation => PI}
  // import com.typesafe.config.Config

  //object PropertyInterpolation {
  val propre = """\{\{(.*)\}\}""".r;

  def propSub(conf:Config, s:String): String = {
    val matches = propre.findAllIn(s)
    matches.matchData.toList.foldLeft(s) {
      case (acc, m) => {
        val before = acc.slice(0, m.start)
        val after = acc.slice(m.end, acc.length)
        val propname = acc.slice(m.start+2, m.end-2).trim
        before + conf.getString(propname) + after
      }
    }
  }

  /**
   * same function as above, but a bit terser and more amenable to implicit configs 
   */
  def psub(s:String)(implicit conf:Config): String = propSub(conf, s)

  def prop(propname:String)(implicit conf:Config): String = 
    conf.getString(propname)


  /**
   * Build URIs using a more readable syntax,
   * one line per parameter, with property substitution, like so:
   *
   * Given property definitions:
   *   file.name=/path/to/file
   *   delay.value=1000
   *
   * Then
   *    mkUri("file:{{file.name}}", """
   *          |  initialDelay={{delay.value}}
   *          |  delay=1000
   *          """)
   * 
   *    mkUri("""|file:{{file.name}}
   *             |  initialDelay={{delay.value}}
   *             |  delay=1000
   *          """)
   * becomes
   *    "file://path/to/file?initialDelay=1000&delay=1000"
   *
   */
  def mkUri(path:String, args:String)(implicit conf:Config): String = {
    val lines = args.trim.stripMargin.split("\n").toList.map(propSub(conf, _).trim)
    val uristr = propSub(conf, path).trim + "?" + lines.mkString("&")
    uristr
  }

}

object ConfigUtils extends ConfigUtils
