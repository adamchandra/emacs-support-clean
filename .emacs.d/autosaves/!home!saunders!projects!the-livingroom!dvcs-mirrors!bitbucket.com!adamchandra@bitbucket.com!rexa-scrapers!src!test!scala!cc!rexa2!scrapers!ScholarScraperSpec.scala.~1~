package cc.giraphe

import org.specs2.mutable
import org.specs2.mutable._

import scalaz._
import scalaz.{Scalaz => z}
import z.{node => _, _}
import org.jdom._
import org.jdom.xpath._

import cc.acs.commons.util.EnrichedJDom._

object XmlParseSpec extends mutable.Specification { // with mutable.Before  {

  "xml fragment parsing" >> {
    def sampleXml = 
      <records>
           <authors>
             <label>Authors</label>
             <values>JENSEN, DA</values>
             <values>SURKO, PT</values>
           </authors>
           <source>
             <label>Pages</label>
             <values>87-87</values>
           </source>
           <source>
             <label>Published.BiblioYear</label>
             <values>1975</values>
           </source>
           <source>
             <label>SourceTitle</label>
             <values>BULLETIN OF THE AMERICAN PHYSICAL SOCIETY</values>
           </source>
           <title>
             <label>Title</label>
             <values>MEASUREMENT OF BRANCHING RATIO FOR KL-]MU+/+MU-(STAR)</values>
           </title>
           <UT>A1975V160400450</UT>
         </records>

    "create an addressable xml fragment" !  {

      // case classes are great for creating ADTs, typeclasses, etc., but 
      // horrible (though extremely tempting) for capturing semi-structured 
      // data in a named structure.
      // Consider name variations from several data sources:
      //  name = JENSEN, DA
      //  name = Jensen, D.
      //  name = David Jensen
      // bad: val (f,m,l) = parse(name); Name(f, m, l)
      // or (bad): MyRec(name, email, dept, ...)

      // First problem: we might have some subset of the fields
      //   so try (bad) MyRec(some(name), Some(email), dept=none, ...)
      //   constructing these case classes becomes difficult to code and use
      //   myRec.name.get (reaaally bad) or myRec.name map (f..) (p.i.t.a.)
      // plus... what does dept=none mean? no dept? unparseable dept?

      // We want to keep track of:
      //   the original mention's text (unparsed, unchanged)
      //   the existence (or non-existence) of a field type
      //     .. the meaning of non-existence of a field is an orthogonal concern
      //   a parsed version of a field (e.g., nameParseForWoS(name))
      //     .. perhaps validated Success(name) | Failure("name")
      // 
      
      // DRY !!!
      val authorsAddr = "records/authors/values"
      val authorAddr = "records/authors/values[??].text"
      
      trait XNode {
        def id: String
      }

      trait XmlNode extends XNode {
        val xml:Element = null
      }

      class WosXmlNode extends XmlNode {
        val authorsAddr = "records/authors/values"
        val authorAddr = "records/authors/values[??].text"
        val wosIdAddr = "records/UT.text"

        def id: String = xpathValue(wosIdAddr, xml)


        // usage: 
        //   n1.authorPath.edgeto(n2.authorPath)
        // creates: 
        //   n1.edgeto("?")("_from" -> "/a/b[n]", "_to" -> "records/authors/values[2].text").to(n2)


        // End-user usage:
        //  (n1.author, n2.author) *** (parseWosAuth, parseHRAuth) apply authDist.curried apply createRel("aligned") 
        //     Option    Option           Valid         Valid            ap(valid)(valid)

        
        // def author: Int => Addressable[XPath, String] = 
        def authorPath: Int => String = n => authorAddr // @ n

        def author: Int => String = 
          n => xpathValue(authorAddr, xml)
      }

      trait TRNode extends XNode {
        
      }
      

      val fauthors: Element => List[String] = 
        e => xpathNodes("records/authors/values", e).toList map (_.getText)

      val fauthor: Int => Element => String = 
        n => e => xpathValue("records/authors/values["+(n+1)+"].text", e)

      val wosIdf: Element => String = 
        e => xpathValue("records/UT.text", e)

      val authors: Lens[Element, List[String]] = Lens(fauthors(_), (obj, v) => obj)
      val author: Int => Lens[Element, String] = n => Lens(fauthor(n)(_), (obj, v) => obj)
      val wosId: Int => Lens[Element, String] = n => Lens(wosIdf(_), (obj, v) => obj)

      // neo4j.exec {implicit gdb => {
      //   val n1 = tableRowNode("row" -> tr1s, "id" -> tr1id.get)
      //   val n2 = xmlNode("xml" -> sampleXml, "id" -> wosId(sampleXml))
      // 
      //   n1.edgeto("aligned")("from" -> "col/0", "to" -> "records/authors/values[2].text").to(n2)
      // }}

      todo
    }

  }
}

