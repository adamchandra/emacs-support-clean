#!/bin/sh
exec scala -savecompiled $0 $@
!#

// split -a 5 -d -l "$batchSize" $infile --filter='cat > $FILE; ../bin/dir-munge.sh $FILE | xargs -i mkdir -p {}; mv $FILE $(../bin/dir-munge.sh $FILE)' 0

object App extends Application {
  import scala.io.Source
  import java.io.{File=>JFile, FileWriter, BufferedWriter}

  def argsToMap(args: Array[String]): Map[String, List[String]] = {
    import scala.collection.mutable.{ListMap => LMap}
    val argmap = LMap[String, List[String]]()
    args.foldLeft(argmap)({(m, k:String) => {
      val ss:Seq[Char] = k
      ss match {
        case Seq('-', '-', opt @ _*) => m.put(opt.toString, List[String]())
        case Seq('-', opt @ _*) => m.put(opt.toString, List[String]())
        case opt @ _ => m.put(m.head._1, m.head._2 ++ List[String](opt.toString))
      }
      m
    }})
    Map[String, List[String]](argmap.toList.reverse: _*)
  }

  override def main(args: Array[String]) = {
    val argmap = argsToMap(args)
    // println(argmap)

    val batchSize = argmap("batch-size").headOption.getOrElse("5").toInt
    val dirDepth = argmap("dir-depth").headOption.getOrElse("3").toInt
    val rootDir = new JFile(argmap("root-dir").headOption.getOrElse("."))

    println("batchSize: " + batchSize)
    println("dir depth: " + dirDepth)

    def fileNumToPath(n:Int): JFile = {
      val fname = "%05d".format(n)
      val pre = (fname split "").drop(1).take(dirDepth).mkString("/")
      // println("fname = " + fname)
      // println("pre = " + pre)
      // val pre = ((fname split "") mkString "/").drop(1)
      new JFile(rootDir, new JFile(pre, fname).getPath)
    }

    def maybeMkdirs(f:JFile) { 
      val p = f.getParentFile
      if (!p.isDirectory) p.mkdirs()
    }

    def newWriter(f:JFile):BufferedWriter = { 
      new BufferedWriter(new FileWriter(f))
    }

    val (_, lastFileInfo) = Source.stdin.getLines.foldLeft( 
      (0, None:Option[(Int, BufferedWriter)]) 
    )({
      case ((linesWritten, fileInfo:Option[(Int, BufferedWriter)]), line) => {
        // println("written, fileInfo = "+(linesWritten, fileInfo))
        // println("line = " + line)
        
        val (currLinesWritten, currFilenum, currWriter) = 
          (fileInfo
            map({case (filenum, writer) => {
              if (linesWritten < batchSize) {
                (linesWritten, filenum, writer)
              }
              else {
                writer.close
                val fnum = filenum+1
                val fn = fileNumToPath(fnum)
                maybeMkdirs(fn)
                (0, fnum, newWriter(fn))
              }
            }})
            getOrElse {
              val fn = fileNumToPath(0)
              maybeMkdirs(fn)
              (0, 0, newWriter(fn))
            }
          )
        
        // println("  writing to filenum: " + currFilenum)
        // println("  curr = " + (currLinesWritten, currFilenum, currWriter))
        currWriter.write(line); currWriter.newLine()
        
        (currLinesWritten+1, Some(currFilenum, currWriter))
      }}
    )
    lastFileInfo foreach {case (_, w) => w.close}

  }
}

