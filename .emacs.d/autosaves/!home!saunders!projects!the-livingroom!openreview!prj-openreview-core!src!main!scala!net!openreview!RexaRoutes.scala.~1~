package cc.rexa2.camel
package routes

import scalaz.{Scalaz => Z, _}
import scalaz.Scalaz.{node => _, _}
import edu.umass.cs.iesl.scalacommons.util.StringOps._
import edu.umass.cs.iesl.scalacommons.util.FileOps._
import cc.rexa2.commons.{Props => P, PropertyInterpolation => PI}
import PI._
import com.typesafe.config.Config

import org.apache.camel
import camel.scala.dsl.builder.{RouteBuilder, RouteBuilderSupport}
import camel.{CamelContext, Exchange, ExchangePattern}
import camel.component.exec.ExecBinding
import camel.component.properties.PropertiesComponent

import cc.rexa2.camel.commons.CamelOps._
import com.weiglewilczek.slf4s.Logging
import org.scala_tools.subcut.inject._


class Routing(implicit val bindingModule: BindingModule) extends Injectable with Logging {
  val log = logger

  implicit val props = inject[Config]('config)

  import scala.collection.JavaConverters._


  def loadRoutes = {
    import org.apache.camel.spring.SpringCamelContext._
    val activeRoutes = props.getStringList("camel.routes.active").asScala 

    val camelContext = springCamelContext("/camel-context.xml")
    val template = camelContext.createProducerTemplate

    log.info("starting route groups: ")
    activeRoutes foreach { routeGroup => {
      log.info("  starting route group " + routeGroup)
      routingGroups(routeGroup).values.foreach (_.addRoutesToCamelContext(camelContext))
    }}

    // run this from 
    // template.sendBody("direct:pstotext.pending", testFiles);
    template
  }


  // val testFiles = (
  //   """
  //   |0/0/0/A/000A00181E1C0F6AE3A11AD18972CE4442E7CB42.pdf
  //   |0/0/0/A/000A038DB9739DF8A8C7850C6565A108577B7572.pdf
  //   |0/0/0/A/000A04CFFD3E20EF47B45FA404265E36AF645EFF.pdf
  //   |0/0/0/A/000A0AF634D7D84C4C70F527918699CFC868DB34.pdf
  //   |0/0/0/A/000A0F2F0434AC34BCE43595EAA8C4D6AC666EE8.pdf
  //   |0/0/0/A/000A1EDBB7721085F1C8CA937A342D89851DFBD7.ps
  //   |0/0/0/A/000A251DCD079B54D1C697D8499CA0FABAED038D.pdf
  //   |0/0/0/A/000A2E29A2DC93C740E2521830FB42702FB4810D.pdf
  //   |0/0/0/A/000A5ACEBED3565DCBB1717229C6227D8CD35BA6.ps
  //   |0/0/0/A/000A5D9A71D259567601205B153DBCC2553571F5.pdf
  //   |0/0/0/A/000A5F9764843E5ADB8FE535D7197090FB7B59FD.ps
  //   |0/0/0/A/000A6C9611DFAAB2B2DAC5DFEB91127910972BFA.pdf
  //   |0/0/0/A/000A70C6B4BB2F0F8B26E348EC3325918021960E.pdf
  //   """
  //   .stripMargin.split("\n")
  //   .toSeq map (_.trim));

  val routingGroups = Map[String, Map[String, RouteBuilder]](

    "testingRoutes" -> Map[String, RouteBuilder](
      // test code will just round-trip and log an activemq message 
      "echoClientIn" -> new RouteBuilder {
        val asdf = from("direct:echo.in") ==> {
          to("activemq:echo.in") 
        }
        asdf
      },

      "echoClientOut" -> new RouteBuilder {
        from("activemq:echo.in") ==> {
          to("log:info") 
        }
      }

    ),

    "clientRoutes" -> Map[String, RouteBuilder](

      // Seq[String] => ()
      "direct:pstotext.pending" -> new RouteBuilder {
        from("direct:pstotext.pending") ==> {
          to("activemq:pstotext.pending") 
        }
      }

    ),

    // run one instance of these routes on gridengine
    "gridengineHeadRoutes" -> Map[String, RouteBuilder](
      "submit.sge.script" -> new RouteBuilder {
        from("activemq:pstotext.sge.scripts") ==> {
          // write the scripts to a directory
          to(fmtComp("file:{{path.var.script.sge.pstotext}}", """
                     |  fileName=sge-pstotext-${id}
                     |  tempFileName=.0-${headers.CamelFileNameProduced}
                     """))

          // submit the scripts to the grid
          to(fmtComp("exec:{{path.app.sge.qsub}}", """
                     |  args=${headers.CamelFileNameProduced}
                     |  useStderrOnEmptyStdout=true
                     """))
          to("log:info")
        }
      }

      // TODO route using qstat to monitor progress/kill errant jobs
    ),



    "serverRoutes" -> Map[String, RouteBuilder](
      // read files as input to pstotext queue (directory)
      "echoServerSide1" -> new RouteBuilder {
        from("activemq:echo.in") ==> {
          as(classOf[String])
          transform(_.in[String].split("\n").toSeq.map("echo:"+_))
          to("activemq:echo.out")
        }
      },

      
      "pstotext.pending" -> new RouteBuilder {
        // Seq[String] => String (script)
        from("activemq:pstotext.pending") ==> {
          (to("log:info")
           setHeader("working.corpus.root", prop("path.corpus.rexa.pdfs"))
           setHeader("pstotext.app.root", prop("path.app.pstotext")))
          to("scalate:/sge-pstotext-template.ssp") // => 
          to("activemq:pstotext.sge.scripts")
        }
      },
      
      // read files as input to pstotext queue (directory)
      "pstotextFileInput" -> new RouteBuilder {
        from(
          fmtComp("file:{{path.var.queue.pstotext}}", """
                  |  initialDelay=1000
                  |  delay=1000
                  |  runLoggingLevel=TRACE
                  |  recursive=false
                  |  delete=false
                  |  readLock=markerFile
                  """)) ==> {
            as(classOf[String])
            transform(_.in[String].split("\n").toSeq)
            to("direct:create.script.pstotext")
          }
      },
      
      // expects a set of filenames as Seq[String]
      "pstotextSgeRoute" -> new RouteBuilder {
        "direct:create.script.pstotext" ==> {
          (to("log:info")
           setHeader("working.corpus.root", prop("path.corpus.rexa.pdfs"))
           setHeader("pstotext.app.root", prop("path.app.pstotext")))
          to("scalate:/sge-pstotext-template.ssp")
          to(fmtComp("file:{{path.var.script.sge.pstotext}}", """
                     |  fileName=sge-pstotext-${id}
                     |  fileExist=Fail
                     |  tempFileName=.0-${headers.CamelFileNameProduced}
                     """))
        }
      }


      // val testRoute = new RouteBuilder {
      //   from(fmtComp("file:{{path.var.script.sge}}", """
      //                |  initialDelay=1000
      //                |  delay=1000
      //                """)) ==> {
      //     to(fmtComp("exec:rsync", """
      //                |  args=-avz /home/saunders/projects/the-livingroom/rexa2-front-play-bb-in/README.md blake.cs.umass.edu:/iesl/canvas/saunders/the-world/the-kitchen/
      //                |  outFile=rsync-output.log
      //                |  useStderrOnEmptyStdout=true
      //                """))
      //   }
      // }



      // submit the scripts for running jobs on gridengine
      // "rsyncToGridengine" -> new RouteBuilder {
      //   from(fmtComp("file:{{path.var.script.sge}}", """
      //                |  initialDelay=1000
      //                |  delay=5000
      //                |  runLoggingLevel=TRACE
      //                |  noop=true
      //                |  recursive=false
      //                """)) ==> {
      // 
      // 
      //     // TODO figure out how to make exec errors show up somewhere (log file? exception?)
      //     to(fmtComp("exec:rsync", """
      //                |  args=-avz /home/saunders/projects/the-livingroom/rexa2-front-play-bb-in/README.md blake.cs.umass.edu:/iesl/canvas/saunders/the-world/the-kitchen/
      //                |  outFile={{path.var.log.rsync}}/rsync-output.log
      //                |  useStderrOnEmptyStdout=true
      //                """))
      // 
      //     to(fmtComp("file:{{path.var.log.rsync}}", """
      //                |  fileExist=Fail
      //                """))
      //   }
      // }

    )
  )
  

  //    TODO: iterate over all files in a repo, building a list of files that need processing
  //  route message (based on header) to local processing, remote processing, or grid engine
  //  create indexed and browsable result set
  //  optimize pdfs for web viewing
  //  deep-link to bibliography/header sections



  /// Can't get this to work properly...
  //       to(fmtComp("exec:rsync", """
  //                  |  args=-avz {{var.script.sge.d}}/* blake.cs.umass.edu:/iesl/canvas/saunders/the-world/the-kitchen/var/
  //                  |  outFile=rsync.log
  //                  |  useStderrOnEmptyStdout=true
  //                  """))
}

