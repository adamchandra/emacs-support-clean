package lib.core
package model

// import scalaz._, Scalaz._

import play.api.db._
import anorm._
import anorm.SqlParser._
import java.util.Date

import play.api.Play.current

import securesocial.core.{AuthenticationMethod}
import securesocial.core.PasswordInfo

import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._

object LinkedAccount {
  // TODO put indices on provider_user_id/key
  val parser = {
    get[Pk[Long]]("id") ~
    get[Long]("user_id") ~
    get[String]("provider_user_id") ~
    get[String]("provider_key") ~
    get[String]("auth_method") map {
      case (
        id ~
        userId ~
        providerUserId ~
        providerKey ~
        authMethod
      ) => LinkedAccount(id.get, userId, providerUserId, providerKey, authMethod)
    }
  }



  def forUser(userId: Long): List[LinkedAccount] = { // TODO: Make NonEmptyList?
    DB.withConnection { implicit c =>
      val result: List[LinkedAccount] =
        SQL(
          """
          select id, user_id, provider_user_id, provider_key, auth_method
          from linked_account
          where user_id = {userId};
          """
        ) on (
          'userId -> userId
        ) as (parser *)
      result
    }
  }

  def findByProviderId(providerName: String, providedId: String): Option[LinkedAccount] = {
    DB.withConnection { implicit c =>
      SQL(
        """
        select id, user_id, provider_user_id, provider_key, auth_method
        from linked_account
        where provider_user_id = {providedId} and provider_key = {providerName};
        """
      ) on (
        'providerName -> providerName,
        'providedId -> providedId
      ) as (parser.singleOpt)
    }
  }

  def find(): List[LinkedAccount] = { 
    DB.withConnection { implicit c =>
      SQL( """select id, user_id, provider_user_id, provider_key, auth_method from linked_account;""" ) 
      .as (parser *)
    }
  }

  def findById(id: Long): Option[LinkedAccount] = { 
    DB.withConnection { implicit c =>
      SQL(
        """
        select id, user_id, provider_user_id, provider_key, auth_method
        from linked_account
        where id = {id};
        """
      ) on (
        "id" -> id
      ) as (parser.singleOpt)
    }
  }


  // def create(linkedAccount: LinkedAccount): Validation[String, LinkedAccount] = {
  //   val oid = DB.withConnection { implicit connection =>
  //     SQL( """|
  //       | insert into linked_account(id, user_id, provider_user_id, provider_key)
  //       | values (
  //       | 0, {userId}, {providerUserId}, {providerKey}
  //       | )
  //       """.stripMargin
  //     ).on (
  //       'userId -> linkedAccount.userId,
  //       'providerUserId -> linkedAccount.providerUserId,
  //       'providerKey -> linkedAccount.providerKey
  //     ).executeInsert()
  //   }
  // 
  //   for {
  //     id <- oid.toSuccess("linked account insert failed")
  //     acc <- findById(id).toSuccess("linked account find on newly inserted failed")
  //   } yield acc
  // }

  def create(user:User, providerUserId: String, providerKey: String, authMethod: String): Validation[String, LinkedAccount] = {
    val oid = DB.withConnection { implicit connection =>
      SQL( """
        insert into linked_account(id, user_id, provider_user_id, provider_key, auth_method)
        values ( NULL, {userId}, {providerUserId}, {providerKey}, {authMethod} )
        """.stripMargin
      ).on (
        'userId -> user.id,
        'providerUserId -> providerUserId, // linkedAccount.providerUserId,
        'providerKey -> providerKey, // linkedAccount.providerKey
        'authMethod -> authMethod
      ).executeInsert()
    }

    for {
      id <- oid.toSuccess("linked account insert failed")
      acc <- findById(id).toSuccess("linked account find on newly inserted failed")
    } yield acc
  }


  def createForEmailPassword(user: User, info: PasswordResetInfo): Validation[String, LinkedAccount] = {
    // TODO saltier password
    create(user, info.password, AuthenticationMethod.UserPassword.method, AuthenticationMethod.UserPassword.method)
  }

}

/**
 * for username/password, providerUserId=<hashed-user-password>, providerKey="password"
 * TODO: rename SecureSocial AuthMethods to "*AuthMethod" and UserPassProvider to "userpassProvider"
 */
case class LinkedAccount(id:Long, userId: Long, providerUserId: String, providerKey: String, authMethod: String)  {

  // def delete(): Validation[String, Unit] = {
  //   val updated = DB.withConnection { implicit connection => {
  //     SQL("delete from token_action where id = {id};")
  //     .on (
  //       'id -> id
  //     ).executeUpdate()
  //   }}
  //   if (updated==1) ().success else "error deleting linked account".failure
  // }

  def updateProviderUserId(newProviderUserId: String): Validation[String, Unit] = {
    val updated = DB.withConnection { implicit connection => {
      SQL("""
        update linked_account 
        set provider_user_id={providerUserId} 
        where id = {id};"""
      ).on (
        'id -> id,
        'providerUserId -> newProviderUserId
      ).executeUpdate()
    }}
    if (updated==1) ().success else "error updating linked account".failure
  }

}

