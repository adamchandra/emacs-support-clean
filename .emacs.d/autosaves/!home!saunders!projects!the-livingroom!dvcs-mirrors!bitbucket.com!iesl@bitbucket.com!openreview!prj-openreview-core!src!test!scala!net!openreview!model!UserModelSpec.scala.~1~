package net.openreview
package model
package user

import com.mongodb.casbah.Imports._
import org.specs2.mutable._
import org.specs2.specification.{ Scope, Step }
import com.mongodb.casbah.commons.test.CasbahMutableSpecification
import java.util.UUID

import com.novus.salat._
import com.novus.salat.dao._
import com.novus.salat.annotations._
import se.radley.plugin.salat._
import net.openreview.model.mongodb.salatContext._

import com.novus.salat.util.MapPrettyPrinter
import net.liftweb.json._
import net.liftweb.json.NoTypeHints
import org.joda.time.DateTime


class DocumentStoreSpec extends MongoSpec {

  // RegisterURLHelpers()


  "a first test" should {

    "round trip store/retrieve events" in {

      // val cc = CC("sdf".n)
      // val dcc = grater[CC].asDBObject(cc)
      // println(dcc)

      // val bev = BaseEventDAO(
      //   uuid = UUID.randomUUID, 
      //   created = DateTime.now,
      //   creator  = UUID.randomUUID, 
      //   target= UUID.randomUUID, 
      //   ephemeralText = None, 
      //   subject = "subject:".n
      // )
      // 
      // val dbev = grater[BaseEventDAO].asDBObject(bev)
      // 
      // println(dbev)
      // 
      // val eid = EventModelStore.insert(bev) // t:EventDAO, wc:WriteConcern)
      // 
      // eid must not beNone
      // 
      // println(eid)
      // 
      // val evR  = EventModelStore.findOneById(eid.get)
      // 
      // println("==============================")
      // println("doc: "+evR)
      // 
      // evR must not beNone
      // 
      // // sdf must haveClass(classOf[net.openreview.model.PrimaryEvent])
      // evR map (_ must beAnInstanceOf[BaseEventDAO])


      // DevData.authors
      // DevData.iclr

      // doc3review1license
      // doc3review1fulfill

      // implicit val formats = Serialization.formats(NoTypeHints) + new UUIDSerializer()
      val dbname = "or-testdb"

      Storage.setStorage(new MongoStorage(MongoConnection(), dbname))

      // import Storage._
      val devData = new DevData(Storage)

      val eventStore = new EventModelStore(MongoConnection(), dbname)
      val documentStore = new DocumentModelStore(MongoConnection(), dbname)
      val eventProcessorStore = new EventProcessorModelStore(MongoConnection(), dbname)

      devData.events.foreach { event =>
        val evInput = event.toDAO
        // val oinsId = Storage.eventStore.insert(evInput)
        val oinsId = eventStore.insert(evInput)
        val insId = oinsId.get
        insId must be_==(evInput._id)
        insId must be_==(event.uuid)
        val evS  = eventStore.findOneById(insId)
        evS must not beNone

        val dbo = eventStore.toDBObject(evInput)
        val dbo2 = eventStore.toDBObject(evS.get)
        
        // println("==============================")
        // println("in => ")
        // println(MapPrettyPrinter(dbo))
        // 
        // println("out =>")
        // println(MapPrettyPrinter(dbo2))
        // 
        // println("==============================")
      }

      devData.docs.foreach { document =>
        val ddao = document.toDAO
        val docId  = documentStore.insert(ddao)
        docId must not beNull;
        docId.get must be_==(document.uuid)

        val docDaoR  = documentStore.findOneById(docId.get)
        docDaoR must not beNull;
        val docR = docDaoR.get.toDocument

        val dbo = documentStore.toDBObject(ddao)
        val dbo2 = documentStore.toDBObject(docDaoR.get)
        
        // println("==============================")
        // println("in => ")
        // println(MapPrettyPrinter(dbo))
        // 
        // println("out =>")
        // println(MapPrettyPrinter(dbo2))
        // 
        // println("==============================")

      }

      devData.authorNodes.foreach { eventProcessor =>
        val ddao = eventProcessor.toDAO
        val eprocId  = eventProcessorStore.insert(ddao)
        eprocId must not beNull;
        eprocId.get must be_==(eventProcessor.uuid)

        val eprocDaoR  = eventProcessorStore.findOneById(eprocId.get)
        eprocDaoR must not beNull;
        val eprocR = eprocDaoR.get.toEventProcessor

        val dbo = eventProcessorStore.toDBObject(ddao)
        val dbo2 = eventProcessorStore.toDBObject(eprocDaoR.get)
      }

      // DevData.groupNodes.foreach { eventProcessor =>
      // }
      // 
      // DevData.groupNodes.foreach { eventProcessor =>
      // }

      // val event = DevData.doc3review1fulfill // doc1endorsementRequest
      // println("==============================")
      // // println("event: "+event)
      // val ev = EventDAO.fromEvent(event)
      // // println("ev: "+ev)
      // // val sdf = UUID.randomUUID()
      // 
      // val insId = EventModelStore.insert(ev)
      // 
      // println("==============================")
      // println("insId: "+insId.get.getClass)
      // println("evId: "+event.uuid)
      // val evR  = EventModelStore.findOneById(insId.get)
      // val evS  = EventModelStore.findOneById(event.uuid)
      // 
      // println("==============================")
      // println("doc: "+evR)
      // println("==============================")
      // println("doc: "+evS)
      // 
      // evR must not beNone
      // 
      // // sdf must haveClass(classOf[net.openreview.model.PrimaryEvent])
      // evR map (_ must beAnInstanceOf[FulfillEventDAO])

      success
    }

    // "start and stop a db" in {
    // 
    //   val urlDoc = UrlDocumentDAO(
    //     url = new java.net.URL("http://some.url"),
    //     uuid = UUID.randomUUID,
    //     // date = new java.util.Date()
    //     created = new org.joda.time.DateTime(),
    //     creator = UUID.randomUUID, // EventProcessor
    //     title= Some("this is a title".n), // : Option[NonemptyString]
    //     authors = None,
    //     summary = Some("a summary".n), // : Option[NonemptyString] = None,
    //     lastRevision = Some(UUID.randomUUID) // Option[UUID] = None,
    //   )
    // 
    //   val textDoc = PlainTextDocumentDAO(
    //     uuid = UUID.randomUUID,
    //     // date = new java.util.Date()
    //     created = new org.joda.time.DateTime(),
    //     creator = UUID.randomUUID, // EventProcessor
    //     title= Some("this is a title".n), // : Option[NonemptyString]
    //     authors = None,
    //     summary = Some("the text of the document".n), // : Option[NonemptyString] = None,
    //     lastRevision = Some(UUID.randomUUID) // Option[UUID] = None,
    //     // nextRevision: Option[UUID] = None,
    //     // inResponseTo: Option[UUID] = None
    //   )
    // 
    //   for {
    //    urlDocId <- DocumentModelStore.insert(urlDoc) // DevData.doc1
    //    urlDocR <- DocumentModelStore.findOneById(urlDocId)
    //    textDocId <- DocumentModelStore.insert(textDoc) // DevData.doc1
    //    textDocR <- DocumentModelStore.findOneById(textDocId)
    //   } {
    //     // val j = DocumentModelStore.toPrettyJson(doc)
    //     println(urlDocR)
    //     println(textDocR)
    //   }
    // 
    //   // val doc = DocumentModelStore.findOneById(DevData.doc1.uuid)
    //   // println("got doc: " + doc )
    //   // doc.foreach { d =>
    //   //   val j = UrlDocumentModelStore.toPrettyJson(d)
    //   //   println(j)
    //   // }
    // 
    //   todo
    // }
  }

}

// Some(
//   FulfillEventDAO(
//     PrimaryEventDAO(
//       BaseEventDAO(a198c9d0-a1a9-4293-b9d3-2ee8dd1401df,
//                    2013-01-05T15:46:58.834-05:00,
//                    00000000-0001-86a0-0000-000000000003,
//                    150f5fdc-e14e-4b64-8986-9f263c769e08,
//                    None,
//                    Fulfilled: Request for comment),
//       Some(19dc2d36-da44-4d8b-a7e7-4bd8d04f4beb)),
//     fb71fb74-32f1-4e89-8e59-fa25ace3bfff))
