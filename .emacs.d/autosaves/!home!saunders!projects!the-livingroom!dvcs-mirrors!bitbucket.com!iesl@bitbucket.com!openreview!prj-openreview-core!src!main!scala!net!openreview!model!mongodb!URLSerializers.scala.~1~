package net.openreview.model
package mongodb

import java.util.UUID
import java.util.{Date}
import com.novus.salat._
import com.novus.salat.dao._
import com.novus.salat.annotations._
import com.mongodb.casbah.Imports._
import se.radley.plugin.salat._
import com.novus.salat.global._

import com.mongodb.casbah.commons.conversions._
import com.mongodb.casbah.commons.conversions.scala._
import org.bson.{ BSON, Transformer }
import java.net.{URL, URLEncoder}

trait URLHelpers extends URLSerializer with URLDeserializer

trait URLSerializer extends MongoConversionHelper {

  private val encodeType = classOf[URL]
  /** Encoding hook for MongoDB To be able to persist URL to MongoDB */
  private val transformer = new Transformer {
    log.trace("Encoding a URL")

    def transform(o: AnyRef): AnyRef = o match {
      case url: java.net.URL => url.toExternalForm() 
      case _ => o
    }

  }

  override def register() = {
    log.debug("Hooking up java.net.URL serializer.")
    BSON.addEncodingHook(encodeType, transformer)
    super.register()
  }

  override def unregister() = {
    log.debug("De-registering java.net.URL serializer.")
    BSON.removeEncodingHooks(encodeType)
    super.unregister()
  }
}

trait URLDeserializer extends MongoConversionHelper {
  private val encodeType = classOf[java.net.URL]
  private val transformer = new Transformer {
    log.trace("Decoding java.net.URL")

    def transform(o: AnyRef): AnyRef = o match {
      case url: String => new URL(url)
      case _ => o
    }
  }

  override def register() = {
    log.debug("Hooking up java.net.URL deserializer")
    /** Encoding hook for MongoDB To be able to read URL DateTime from MongoDB's BSON Date */
    BSON.addDecodingHook(encodeType, transformer)
    super.register()
  }

  override def unregister() = {
    log.debug("De-registering java.net.URL  deserializer.")
    BSON.removeDecodingHooks(encodeType)
    super.unregister()
  }
}

object UrlDocumentModelStore extends ModelCompanion[UrlDocument, UUID] {
  // TODO parameterize
  val collection = MongoConnection()("my_db")("url_document_coll")
  val dao = new SalatDAO[UrlDocument, UUID](collection = collection) {}

}

/**
 * @author <a href="mailto:dev@davidsoergel.com">David Soergel</a>
 */
// class MongoDocumentStore extends DocumentStore {
// 
//   // def foreach[U](f: (Document) => U) {
//   //   contents.values.foreach(f)
//   // }
// 
//   def search(searchTerms: Set[NonemptyString]): MemoryDocumentStoreImpl = MemoryDocumentStoreImpl(contents.values.filter(_.containsTerms(searchTerms)))
// 
//   def fromPoV(to: StatefulEventProcessor) = {
//     val mappedValues: Map[UUID, Option[DocumentPoV]] = contents.toMap mapValues (DocumentPoV(_, to))
//     val flattenedValues: Map[UUID, DocumentPoV] = (mappedValues map {
//       case (u, o) => o.map((u, _))
//     }).flatten.toMap
//     new MemoryDocumentPoVStoreImpl(flattenedValues, to)
//   }
//   def get(uuid: UUID): Option[Document] = contents.get(uuid)
// }


// object MongoEventProcessorStore extends EventProcessorStore with Logging {
//   val byUuid = List(World,StubStatefulEventProcessorImplA,StubStatefulEventProcessorImplB) map (x=>(x.uuid,x)) toMap
//   // val byUuid = "select .. from where .."
// 
//   def getNodeForUserId(userId: Long): Option[StatefulEventProcessor] = {
//     val result = byUserId.get(userId)
//     logger.debug("Finding node for user " + userId + " => " + result)
//     result
//   }
//   def getWorldNode: StatefulEventProcessor = World
//   def getEventsForUserId(userId: Long): Option[EventPoVStore] = getNodeForUserId(userId).map(_.eventsLocalView)
//   def getDocumentsForUserId(userId: Long): Option[DocumentPoVStore] = getNodeForUserId(userId).map(_.docsLocalView)
// 
//   
//   
//   def getWorldEvents: EventPoVStore = getWorldNode.eventsLocalView
//   def getWorldDocuments: DocumentPoVStore = getWorldNode.docsLocalView
//   def get(uuid: UUID) = byUuid.get(uuid)
// }
// 
// object StubEventProcessorStoreImpl extends EventProcessorStore with Logging {
//   val byUserId = Map[Long, StatefulEventProcessor](1L -> StubStatefulEventProcessorImplA, 2L -> StubStatefulEventProcessorImplB)
//   val byUuid = List(World,StubStatefulEventProcessorImplA,StubStatefulEventProcessorImplB) map (x=>(x.uuid,x)) toMap
// 
//   def getNodeForUserId(userId: Long): Option[StatefulEventProcessor] = {
//     val result = byUserId.get(userId)
//     logger.debug("Finding node for user " + userId + " => " + result)
//     result
//   }
//   def getWorldNode: StatefulEventProcessor = World
//   def getEventsForUserId(userId: Long): Option[EventPoVStore] = getNodeForUserId(userId).map(_.eventsLocalView)
//   def getDocumentsForUserId(userId: Long): Option[DocumentPoVStore] = getNodeForUserId(userId).map(_.docsLocalView)
// 
//   
//   
//   def getWorldEvents: EventPoVStore = getWorldNode.eventsLocalView
//   def getWorldDocuments: DocumentPoVStore = getWorldNode.docsLocalView
//   def get(uuid: UUID) = byUuid.get(uuid)
// }
