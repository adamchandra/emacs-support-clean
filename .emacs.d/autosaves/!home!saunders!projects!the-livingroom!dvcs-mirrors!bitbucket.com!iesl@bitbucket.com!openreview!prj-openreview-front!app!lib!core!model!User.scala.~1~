package lib.core
package model

import play.api.db._
import anorm._
import anorm.SqlParser._
import java.util.Date

import play.api.Play.current

import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._



object User {

  val parser = {
    get[Pk[Long]]("id") ~
    get[String]("email") ~
    get[String]("username") ~
    get[Option[String]]("fullname") ~
    get[Date]("last_login") ~
    get[Boolean]("active") ~
    get[Boolean]("email_validated") map {
      case (
        id ~
        email ~
        username ~
        fullname ~
        last_login ~
        active ~
        email_validated
      ) => User(id.get, email, username, fullname, last_login, active, email_validated)
    }
  }

  def create(userInfo: UserRegistrationInfo):  Validation[String, User] = {
    val oid = DB.withTransaction { implicit connection => {
      SQL( """|
        | insert into users(id, email, username, fullname, last_login, active, email_validated)
        | values (NULL, {email}, {username}, {fullname}, NOW(), false, false)
        """.stripMargin
      ).on (
        'email -> userInfo.email,
        'username -> userInfo.username,
        'fullname -> userInfo.fullname
      ).executeInsert()
    }}

    for {
      id <- oid.toSuccess("user insert error")
      user <- findById(id).toSuccess("no user with that id")
    } yield user
  }

  def findById(id: Long): Option[User] = {
    val ouser = DB.withConnection { implicit c =>
      SQL(
        """
        select id, email, username, fullname, last_login, active, email_validated
        from users
        where id = {id};
        """
      ) on (
        "id" -> id
      ) as (parser.singleOpt)
    }

    for {
      user <- ouser
      val accs = LinkedAccount.forUser(user.id)
    } yield user.withLinkedAccounts(accs)
  }


  def findByEmail(email: String): Option[User] = {
    val user = DB.withConnection { implicit c =>
      val result: List[User] =
        SQL(
          """
          select id, email, username, fullname, last_login, active, email_validated
          from users
          where email = {email};
          """
        ) on (
          "email" -> email
        ) as (parser *)
      result.headOption // TODO: insure only one user exists w/given email
    }

    user.map{u=>{
      val accs = LinkedAccount.forUser(u.id)
      u.copy(linkedAccounts=accs)
    }}
  }


  //   def existsByAuthUserIdentity(identity: AuthUserIdentity): Boolean = {
  //   private def getAuthUserFind(identity: AuthUserIdentity): ExpressionList[User] = {
  //   def findByAuthUserIdentity(identity: AuthUserIdentity): User = {
  //   def findByUsernamePasswordIdentity(identity: UsernamePasswordAuthUser): User = {
  //   private def getUsernamePasswordAuthUserFind(identity: UsernamePasswordAuthUser): ExpressionList[User] = {
  //   def merge(oldUser: AuthUser, newUser: AuthUser) {
  //   def addLinkedAccount(oldUser: AuthUser, newUser: AuthUser) {
  //   def setLastLoginDate(knownUser: AuthUser) {
  //   private def getEmailUserFind(email: String): ExpressionList[User] = {
}


case class UserRegistrationInfo(
  email           : String,
  username        : String,
  fullname        : Option[String]
)


case class User(
  id              : Long,
  email           : String,
  username        : String,
  fullname        : Option[String],
  lastLogin       : Date,
  active          : Boolean,
  emailValidated  : Boolean,
  roles           : List[SecurityRole] = List(),
  linkedAccounts  : List[LinkedAccount] = List(),
  permissions     : List[UserPermission] = List()
) { // extends Model with RoleHolder {

  // def addLinkedAccount(acc: LinkedAccount): User = {
  //   val linkedAcc = acc.copy(userId=id)
  //   this.copy(
  //     linkedAccounts=linkedAccounts ++ Seq(linkedAcc)
  //   )
  // }

  def withLinkedAccounts(accs: List[LinkedAccount]): User = {
    this.copy(linkedAccounts=accs)
  }


  def verifyEmail(token: TokenAction): Validation[String, User] = {
    def update = {
      DB.withConnection { implicit connection => {
        SQL( """|
          | update users
          | set email_validated=true
          | where id={id}
          """.stripMargin
        ).on (
          'id -> id
        ).executeUpdate()
      }}
    }
    // is token correct type?
    for {
      t <- TokenAction.validation(token) // if t.isEmailVerification
      val _ = update
      user <- User.findById(id).toSuccess("error finding user w/given id after email verification")
    } yield user
  }


//   def merge(otherUser: User) {
//     for (acc <- otherUser.linkedAccounts) {
//       this.linkedAccounts.add(LinkedAccount.create(acc))
//     }
//     otherUser.active = false
//     Ebean.save(Arrays.asList(Array(otherUser, this):_*))
//   }
//
//   def getProviders(): Set[String] = {
//     val providerKeys = new HashSet[String](linkedAccounts.size)
//     for (acc <- linkedAccounts) {
//       providerKeys.add(acc.providerKey)
//     }
//     providerKeys
//   }
//
//   def getAccountByProvider(providerKey: String): LinkedAccount = {
//     LinkedAccount.findByProviderKey(this, providerKey)
//   }
//
//   def changePassword(authUser: UsernamePasswordAuthUser, create: Boolean) {
//     var a = this.getAccountByProvider(authUser.getProvider)
//     if (a == null) {
//       if (create) {
//         a = LinkedAccount.create(authUser)
//         a.user = this
//       } else {
//         throw new RuntimeException("Account not enabled for password usage")
//       }
//     }
//     a.providerUserId = authUser.getHashedPassword
//     a.save()
//   }
//
//   def resetPassword(authUser: UsernamePasswordAuthUser, create: Boolean) {
//     this.changePassword(authUser, create)
//     TokenAction.deleteByUser(this, Type.PASSWORD_RESET)
//   }
}





//   def create(userInfo: UserRegistrationInfo):  Validation[String, User] = {
//     // val oid = DB.withConnection { implicit connection =>
//     //   SQL( """|
//     //     | insert into users(id, email, username, fullname, last_login, active, email_validated)
//     //     | values (
//     //     | 0, {email}, {username}, {fullname}, NOW(), false, false
//     //     | )
//     //     """.stripMargin
//     //   ).on (
//     //     'email -> userInfo.email,
//     //     'username -> userInfo.username,
//     //     'fullname -> userInfo.fullname
//     //   ).executeInsert()
//     val sql = SQL( """|
//         | insert into users(id, email, username, fullname, last_login, active, email_validated)
//         | values (
//         | 1, {email}, {username}, {fullname}, NOW(), false, false
//         | )
//         """.stripMargin
//       ).on (
//         'email -> userInfo.email,
//         'username -> userInfo.username,
//         'fullname -> userInfo.fullname
//       )
// 
//     // def execute1(getGeneratedKeys: Boolean = false)(implicit connection: java.sql.Connection): (java.sql.PreparedStatement, Int) = {
//     val oid = DB.withConnection { implicit connection => {
//       val statement = sql.getFilledStatement(connection, true)
// 
//       val generatedKeysParser = scalar[Long].singleOpt
//       val up = statement.executeUpdate()
//       val keys = statement.getGeneratedKeys()
// 
//       val asdf = generatedKeysParser(Sql.resultSetToStream(keys)) match {
//         case Success(a) => {
//           println("a: " + a)
//           a
//         }
//         case Error(e) => {
//           println("e?: " + e)
//           sys.error(e.toString)
//         }
//       }
//       asdf
//     }}
// 
//     //   (statement, { statement.executeUpdate() })
//     // }
//     // 
//     // Sql.as(generatedKeysParser, execute1(getGeneratedKeys = true)._1.getGeneratedKeys)
// 
// 
//     // user.linkedAccounts.foreach{ la => u.addLinkedAccount(la)}
//     //   userWithAccounts.linkedAccounts foreach {
//     //     la => LinkedAccount.create(la)
//     //   }
//     //   userWithAccounts.success
//     // }} getOrElse (
//     //   new Exception("createUser() failure").failure
//     // )
// 
// 
//     for {
//       id <- oid.toSuccess("user insert error")
//       user <- findById(id).toSuccess("no user with that id")
//     } yield user
// 
//     // "todo".failure
//   }
