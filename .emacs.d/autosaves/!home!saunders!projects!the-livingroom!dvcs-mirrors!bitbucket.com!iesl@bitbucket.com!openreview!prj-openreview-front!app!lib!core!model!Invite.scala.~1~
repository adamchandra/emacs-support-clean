package lib.core
package model

// import scalaz._, Scalaz._

import play.api.db._
import anorm._
import anorm.SqlParser._
import java.util.Date

import play.api.Play.current

import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._


case class Invite(id:Long, inviterId:Long, invitedId:Long)

object Invite {
  val parser = {
    get[Pk[Long]]("id") ~
    get[Long]("inviter_user_id") ~
    get[Long]("invited_user_id") map {
      case (id~inviterId~invitedId) => 
        Invite(id.get, inviterId, invitedId)
    }
  }

  val fields = "id, inviter_user_id, invited_user_id"

  def create(inviterId: Long, email: String): Validation[String, Invite] = {
    for {
      targetUser <- User.create(username = "", fullname="", email=Some(email))
      val oid = DB.withConnection { implicit c =>
        SQL(
          """ insert into invite(%s) values ( NULL, {inviterId}, {invitedId} ) """.format(fields) 
        ).on (
          'inviterId -> inviterId,
          'invitedId -> targetUser.id
        ).executeInsert()
      }

      id <- oid.toSuccess("invite insert failed")
      invite <- findById(id).toSuccess("invite find failed")
    } yield invite
  }


  def findById(id: Long): Option[Invite] = { 
    DB.withConnection { implicit c =>
      SQL(
        """ select %s from invite where id = {id}; """.format(fields)
      ) on (
        'id -> id
      ) as (parser.singleOpt)
    }
  }



}



