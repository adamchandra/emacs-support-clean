package net.openreview.model
package users

import java.util.Date


import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._
import securesocial.core.AuthenticationMethod

import com.novus.salat._
import com.novus.salat.dao._
import com.novus.salat.annotations._
import com.mongodb.casbah.Imports._
import com.mongodb.casbah.MongoConnection
import net.openreview.model.mongodb.salatContext._

import java.util.UUID
import org.joda.time.DateTime
import org.joda.time.DateTime
import stub.MemoryStatefulEventProcessorImpl
import stub.MemoryStorageContext._
import com.mongodb.casbah


/**
 * A trait that provides the means to find and save users
 * for the SecureSocial module.
 *
 * @see DefaultUserService
 */
trait SecureSocialUserService extends securesocial.core.UserService {
  import securesocial.core._
  import securesocial.core.providers.{Token => SSToken}

  /**
   * Finds a SocialUser that maches the specified id
   *
   * @param id the user id
   * @return an optional user
   */
  def find(id: UserId): Option[SocialUser] = {
    for {
      la <- linkedAccountStore.findByProviderId(id.providerId, id.id)
      _ = println("UserService.find:LinkedAccount: " + la)
      user <- userStore.findById(la.userId)
      _ = println("UserService.find:User: " + user)
    } yield {
      SocialUser(
        id = id, // : UserId, 
        firstName = "", // : String, 
        lastName = "", // : String, 
        fullName = user.fullname.getOrElse(""), // : String, 
        email = user.email, // : Option[String],
        avatarUrl = None, // : Option[String], 
        authMethod = AuthenticationMethod(la.authMethod), // : AuthenticationMethod,
        passwordInfo = UserPasswordInfo.forUser(la.userId) map (_.toPasswordInfo) // : Option[PasswordInfo] = None
      )
    }
  }

  /**
   * Finds a Social user by email and provider id.
   *
   * Note: If you do not plan to use the UsernamePassword provider just provide en empty
   * implementation.
   *
   * @param email - the user email
   * @param providerId - the provider id
   * @return
   */
  def findByEmailAndProvider(email: String, providerId: String): Option[SocialUser] = {
    // implement me
    None
  }

  // SecureSocial Identity
  /// trait Identity {
  ///   def id: UserId
  ///   def firstName: String
  ///   def lastName: String
  ///   def fullName: String
  ///   def email: Option[String]
  ///   def avatarUrl: Option[String]
  ///   def authMethod: AuthenticationMethod
  ///   def oAuth1Info: Option[OAuth1Info]
  ///   def oAuth2Info: Option[OAuth2Info]
  ///   def passwordInfo: Option[PasswordInfo]
  /// }


  /**
   * Saves the user.  This method gets called when a user logs in.
   * This is your chance to save the user information in your backing store.
   */
  def save(ssIdentity: Identity) {

    if (find(ssIdentity.id).isEmpty) {
      val user: User = new User(UUID.randomUUID(), ssIdentity.email, ssIdentity.fullName, Some(ssIdentity.fullName), DateTime.now(), true, true)
      val linkedAccount = new LinkedAccount(user.id, ssIdentity.id.id, ssIdentity.id.providerId, ssIdentity.authMethod.method)
      val userPasswordInfo = ssIdentity.passwordInfo.map(pinfo => {
        new UserPasswordInfo(UUID.randomUUID(), user.id, pinfo.hasher, pinfo.password, pinfo.salt)
      })


      val userinfo = UserCreationInfo(user, linkedAccount, userPasswordInfo)
      JournalService.saveUser(userinfo)
      userinfo.commit()
      println("user saved: " + user)
    }
  }



  /**
    * Saves a token.  This is needed for users that
    * are creating an account in the system instead of using one in a 3rd party system.
    *
    * Note: If you do not plan to use the UsernamePassword provider just provide en empty
    * implementation
    *
    * @param token The token to save
    * @return A string with a uuid that will be embedded in the welcome email.
    */
  def save (token: Token): Unit = {

    println ("user save(token): " + token)
    // implement me
  }


  /**
    * Finds a token
    *
    * Note: If you do not plan to use the UsernamePassword provider just provide en empty
    * implementation
    *
    * @param token the token id
    * @return
    */
  def findToken (token: String): Option[Token] = {
    // implement me
    None
  }

  /**
    * Deletes a token
    *
    * Note: If you do not plan to use the UsernamePassword provider just provide en empty
    * implementation
    *
    * @param uuid the token id
    */
  def deleteToken (uuid: String) {
    // implement me
  }

  /**
    * Deletes all expired tokens
    *
    * Note: If you do not plan to use the UsernamePassword provider just provide en empty
    * implementation
    *
    */
  def deleteExpiredTokens () {
    // implement me
  }



}
