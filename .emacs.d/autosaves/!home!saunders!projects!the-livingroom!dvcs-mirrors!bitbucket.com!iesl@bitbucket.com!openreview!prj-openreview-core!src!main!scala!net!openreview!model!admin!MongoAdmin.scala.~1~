package net.openreview.model.admin

import com.mongodb.casbah.MongoConnection
import com.weiglewilczek.slf4s.Logging
import edu.umass.cs.iesl.scalacommons.StringUtils._
import java.util.UUID
import net.openreview.model.journal.BasicJournal
import net.openreview.model.pov.UserViewpoint
import net.openreview.model.raw.Storage._
import net.openreview.model.raw._
import eventprocessors.{MutableMailingList, ArchiveGrantingMutableMailingList}
import memory.{MemoryAnonymizer, MemoryMutableMailingList}
import net.openreview.model.raw.casbah._
import net.openreview.model.seed.{DevData, IclrDataCreator, IclrData, TestingData}
import net.openreview.util.ViewpointCache
import org.joda.time.DateTime
import scala.Some
import scalax.io.Resource
import scalaz.Failure
import scalaz.Success
import users.{User, MemoryUser}
import ch.qos.logback.classic.LoggerContext
import org.slf4j.LoggerFactory
import ch.qos.logback.core.util.StatusPrinter


object MongoAdmin extends Logging {


  def setup(args: Array[String]) {

    // assume SLF4J is bound to logback in the current environment
    val lc:LoggerContext  =LoggerFactory.getILoggerFactory().asInstanceOf[LoggerContext]
    // print logback's internal status
    StatusPrinter.print(lc)
    
    logger.info("[openreview] using MongoDB backend storage: %s".format(this.getClass))

    com.mongodb.casbah.commons.conversions.scala.RegisterConversionHelpers()
    com.mongodb.casbah.commons.conversions.scala.RegisterJodaTimeConversionHelpers()
    net.openreview.model.mongodb.RegisterURLHelpers()

    val dbname = args(0)
    StorageSetter(new CasbahStorage(MongoConnection("localhost"), dbname))

  }


  def renderEvents() {

    import com.mongodb.casbah.commons.MongoDBObject
    import com.mongodb.DBObject


    def iconic[A](f:String)(implicit dbo: MongoDBObject, m:Manifest[A]) = {
      f + ": " +(dbo.getAs[A](f).getOrElse("???"))
    }

    // creator: 1234-..
    //   "John Smith et.al."
    //   {_id: 1234-}
    // name, value, link

    def iconicRef[A](f:String)(implicit dbo: MongoDBObject, m:Manifest[A]) = {
      val id = dbo.getAs[A](f).get
      f match {
        case "creator" | "target" => 
          val ep = eventProcessorStore.get(id.toString).get
          f + ": "+id+":"+ep.name+"{_id: ...}"
        case _ => 
          f + ": "+id
      }
    }



    def full(implicit dbo: MongoDBObject)  {
      // (type <|> ":" <|> _id) </> name </> ref
      println(
        List(
          iconic[String]("type"),
          iconic[UUID]("_id"),
          iconicRef[UUID]("creator"),
          iconicRef[UUID]("target")
        ).mkString(", ")
      )
      // "type"    ,
      /// "created" ,

      dbo.foreach { case (fname, fvalue) => {
        fname match {
          case "type" =>
          case "_id" =>
          case "creator" => 
          case "target" =>
          case "created" =>

          case "template" =>
          case "due" =>
          case "sticky" =>
          case "ephemeralText" =>
          case "prerequisiteTo" =>
          case "subject" =>
          case "doc" =>
          case "wrapped" =>
          case "_history" =>
          case "eventProcessor" =>
          case "inResponseTo" =>
          case "fulfillingEvent" =>
          case _ => 
            println("don't know how to render "+fname+" -> "+fvalue)
        }

        if (fvalue.isInstanceOf[UUID]) {
          // println(": "+fname+" -> "+fvalue)
        } else if (fvalue.isInstanceOf[DBObject]) {
          // 
        }
      }}

    }

    eventStore.all.foreach { event => 
      val mongoEvent = event.asInstanceOf[MongoEvent]
      val dbo = mongoEvent.dbo
      full(dbo)
    }
  }

