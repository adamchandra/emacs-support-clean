package net.openreview.model
package users


import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._
import java.net.URI
import org.joda.time.{DateTime, Period}
import java.util.UUID

import com.novus.salat._
import com.novus.salat.dao._
import com.novus.salat.annotations._
import com.mongodb.casbah.Imports._
import com.mongodb.casbah.MongoConnection
import net.openreview.model.mongodb.salatContext._


@Salat
trait TokenAction {
  @Key("_id") def id: UUID
  def callback: URI
}

trait ActionMethods {
  def deleteAction(a: TokenAction): Validation[String, Unit]
}

case class EmailVerificationAction(
  val userId: UUID,
  val email: String,
  val id: UUID
) extends TokenAction {
  override def callback: URI = URI.create("/token/email/verify")
}


case class ReviewerInviteAction(
  val reviewer: User,
  val id: UUID
) extends TokenAction {
  override def callback: URI = URI.create("/token/reviewer/verify")
}



trait ActionDAO extends ActionMethods with ModelCompanion[TokenAction, UUID] {
  val collname: String = "Action"
  def conn: MongoConnection
  def dbname: String
  // TODO: why is this not using the supplied connection?
  def collection = MongoConnection()(dbname)(collname)
  lazy val _dao = new SalatDAO[TokenAction, UUID](collection = collection) {}
  override def dao = _dao


  def delete(a: TokenAction): Validation[String, Unit] = {
    val res = remove(a)
    val err = res.getLastError()
    if (!err.ok()) 
      err.getErrorMessage().failure
    else 
      ().success
  }

}

