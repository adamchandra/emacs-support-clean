* CONFIG
*** org-mode configuration
   :HIDDEN:
   :END:


* <2011-05-27 Fri>
*** From Monoids to Monads 
    from A Neighborhood of Infinity by sigfpe
    Generalising Monoids

    + didn't get very far. I don't understand this construction (the '<#>' in particular): 
      <2012-02-04 Sat>: <#> is explained down further as (more or less) <*>

        The law for multiplication on the left is then given by law1_left == law1_middle and so on:
        >     law1_left,law1_middle,law1_right :: m -> m
        >     law1_left   = mult . (one <#> id) . lambda
        >     law1_middle = id
        >     law1_right  = mult . (id <#> one) . rho

*** (evening) read through some more of a smattering of papers, mostly about bananas

* <2011-06-01 Wed>
*** Continuing work on labeled strings, and trying to define the functions and type
    classes in terms of the functional ecosystem

*** Finger trees Done Right article
    - Good explanation of finger trees as a generalization of zippers

    - Short foray into histomorphic functions, which are functions that map a structure to 
      a function of a value and set of substructures (dynamic programming model)
      e.g., tree[a] histomorph maps each node to f(a, (children(node) map.histomorph f))


*** Wednesday June 08, 2011
    - worked furiously at understanding this:
      http://stackoverflow.com/questions/2602276/closures-and-universal-quantification/2604057#2604057]
      Still not really seeing the various types clearly.

*** Understanding foldl in terms of foldr If you want to set yourself a solid challenge, try to follow
    the above definition of foldl using foldr. Be warned: this is not trivial! You might want to have
    the following tools at hand: some headache pills and a glass of water, ghci (so that you can find
    out what the id function does), and a pencil and paper. 11 comments
    + from: http://book.realworldhaskell.org/read/functional-programming.html    
     | -- file: ch04/Fold.hs                     |
     | myFoldl :: (a -> b -> a) -> a -> [b] -> a |
     |                                           |
     | myFoldl f z xs = foldr step id xs z       |
     | where step x g a = g (f a x)              |



*** Space leaks and strict evaluation (need to reread this soon)
    + from: http://book.realworldhaskell.org/read/functional-programming.html    
    The foldl function that we discussed earlier is not the only place where space leaks can arise in
    Haskell code. We will use it to illustrate how non-strict evaluation can sometimes be problematic,
    and how to solve the difficulties that can arise. No comments



*** Multiplate ???
    http://www.haskell.org/haskellwiki/Multiplate



*** Perhaps a description of why map/contramap are different in scala than haskell??
    http://blog.tmorris.net/critique-of-oderskys-scala-levels/

    I (we: scalaz) propose that there is another level again, where you come to the realisation that
    variance annotations are not worth their use in the context of Scala’s limited type-inferencing
    abilities and other details. Instead, prefer a short-hand version of fmap and contramap
    functions. Scalaz calls these ∘ and ∙. The details of why this is more appropriate are beside
    the point here. Nevertheless, Edward Kmett has set out to prove this hypothesis wrong. Many of
    us have and failed. As far as I know, there is nothing compelling yet but I wish Ed luck with
    his unique insights.

***** Variance annotations and type inferencing limitations
      f: -A => +B

      Map[-A, +B]


*** Edit Lenses: http://dmwit.com/papers/201107EL.pdf

*** The Algebra of Data, and the Calculus of Mutation http://blog.lab49.com/archives/3011
    Supposedly excellent description of ADT
    


*** State monad resource:
    [[http://stackoverflow.com/questions/7734756/scalaz-state-monad-examples][url: scalaz-state-monad-examples]]


*** Iteratees, Trampolines, Conduits, Pipes, etc.
    [[http://themonadreader.files.wordpress.com/2011/10/issue19.pdf#page=29][TMR: Coroutine Pipelines]]
    Note: gives a good, intuitive explanation of trampolined computations

***** From The Monad Reader 16:
      I have frequently heard reports from Haskellers (including highly-talented and
      experienced users) that the only way they could understand enumeration-based
      I/O was by re-implementing it themselves. I hope that this document will make a
      contribution towards greater understanding of iteratees, and allow readers the op-
      portunity to explore this exciting new development without rebuilding everything
      themselves.


*** On deck: 
    First: 
      [[http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf][Functional Programming with Overloading and Higher-Order Polymorphism]]
    Then: 
      [[http://debasishg.blogspot.com/2011/07/datatype-generic-programming-in-scala.html][Datatype generic programming in Scala - Fixing on Cata]]
      [[http://debasishg.blogspot.com/2012/01/list-algebras-and-fixpoint-combinator.html][List Algebras and the fixpoint combinator Mu]]
      [[http://debasishg.blogspot.com/2012/01/learning-type-level-fixpoint-combinator.html][Learning the type level fixpoint combinator Mu]]

    Soon: 
      http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours



*** Scalaz comprehension
