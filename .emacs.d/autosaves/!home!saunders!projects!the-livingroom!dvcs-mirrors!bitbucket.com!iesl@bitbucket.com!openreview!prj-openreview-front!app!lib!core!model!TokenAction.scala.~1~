package lib.core


import play.api.db._
import anorm._
import anorm.SqlParser._
import java.util.Date

import play.api.Play.current

import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._


object TokenAction {

  sealed trait TokenType 

  object TokenType {
    def fromString(s: String): TokenType = s match {
      case "EV" => EmailVerification
      case "PR" => PasswordReset
      case tt @ _ => throw new RuntimeException("unknown TokenType: '" + tt + "'")
    }

    case object EmailVerification extends TokenType {
      override def toString = "EV"
    }
    case object PasswordReset extends TokenType {
      override def toString = "PR"
    }
  }

  import TokenType._



  def validation(token: TokenAction): Validation[String, TokenAction] = {
    if (token.isValid) token.success else "token is expired".failure
  }

  //   def findByToken(token: String, `type`: Type): TokenAction = {
  //   def deleteByUser(u: User, `type`: Type) {


  def createForEmailVerification(user: User, duration: Long): Validation[String, TokenAction] = {
    create(user.id, EmailVerification, duration)
  }

  def createForPasswordReset(user: User, duration: Long): Validation[String, TokenAction] = {
    create(user.id, PasswordReset, duration)
  }

  def create(targetUserId: Long, ttype: TokenAction.TokenType, durationInSeconds:Long): Validation[String, TokenAction] = {
    import java.util.UUID

    val oid = DB.withConnection { implicit connection =>
      SQL( """|
        | insert into token_action(id,  token,  target_user_id,  type,  created,  duration)
        | values (NULL, {token}, {targetUserId}, {type}, NOW(), {duration})
        """.stripMargin
      ).on (
        'token -> UUID.randomUUID.toString,
        'targetUserId -> targetUserId,
        'type -> ttype.toString,
        'duration -> durationInSeconds
      ).executeInsert()
    }

    for {
      id <- oid.toSuccess("token action insert error")
      token <- findById(id, ttype).toSuccess("no token with that id")
    } yield token
    
  }

  val parseRow = {
    get[Pk[Long]]("id") ~
    get[String]("token") ~
    get[Long]("target_user_id") ~
    get[String]("type") ~
    get[Date]("created") ~
    get[Long]("duration") map {
      case (
        id ~
        token ~
        targetUserId ~
        ttype ~
        created ~
        duration
      ) => TokenAction(id.get, token, targetUserId, TokenAction.TokenType.fromString(ttype), created, duration)
    }
  }

  def findById(id: Long, ttype: TokenType): Option[TokenAction] = {
    DB.withConnection { implicit c =>
      SQL(
        """
        select id,  token,  target_user_id,  type,  created,  duration
        from token_action
        where id = {id} AND type={ttype};
        """
      ) on (
        "id" -> id,
        'ttype -> ttype.toString
      ) as (parseRow.singleOpt)
    }
  }

  def forUserId(id: Long, ttype: TokenType): List[TokenAction] = {
    DB.withConnection { implicit c =>
      SQL(
        """
        select id,  token,  target_user_id,  type,  created,  duration
        from token_action
        where target_user_id = {targetUserId} AND type={ttype};
        """
      ) on (
        'targetUserId -> id, 
        'ttype -> ttype.toString
      ) as (parseRow *)
    }
  }

}


case class TokenAction(id: Long, token: String, targetUserId: Long, ttype: TokenAction.TokenType, created: Date, duration: Long)  {
  def isValid(): Boolean = {
    val now = new Date()
    val expires = new Date(created.getTime + (duration * 1000))
    expires after now
  }

  def delete(): Validation[String, Int] = {
    val updated = 
      DB.withConnection { implicit connection => {
        SQL(
          """ delete from token_action where id = {id}; """
        ).on (
          'id -> id
        ).executeUpdate()
      }}
    if (updated==1) 1.success else "error deleting token".failure
  }
}

