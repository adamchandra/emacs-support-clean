package net.openreview.model
package users

import java.util.Date


import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._
import securesocial.core.AuthenticationMethod


case class UserRegistrationInfo(
  email           : String,
  username        : String,
  fullname        : Option[String]
)

case class PasswordResetInfo(
  email           : String,
  password        : String
)

object User {


def create(userInfo: UserRegistrationInfo):  Validation[String, User] = {
  // val oid = DB.withTransaction { implicit connection => {
  //   SQL( """|
  //     | insert into users(id, email, username, fullname, last_login, active, email_validated)
  //     | values (NULL, {email}, {username}, {fullname}, NOW(), false, false)
  //     """.stripMargin
  //   ).on (
  //     'email -> userInfo.email,
  //     'username -> userInfo.username,
  //     'fullname -> userInfo.fullname
  //   ).executeInsert()
  // }}
  // 
  // for {
  //   id <- oid.toSuccess("user insert error")
  //   user <- findById(id).toSuccess("no user with that id")
  // } yield user
  "TODO".failure
}

def create(username: String, fullname: String, email: Option[String]):  Validation[String, User] = {
  // val oid = DB.withTransaction { implicit connection => {
  //   SQL( """|
  //     | insert into users(id, email, username, fullname, last_login, active, email_validated)
  //     | values (NULL, {email}, {username}, {fullname}, NOW(), false, false)
  //     """.stripMargin
  //   ).on (
  //     'email -> email,
  //     'username -> username,
  //     'fullname -> fullname
  //   ).executeInsert()
  // }}
  // 
  // for {
  //   id <- oid.toSuccess("user insert error")
  //   user <- findById(id).toSuccess("no user with that id")
  // } yield user
  "TODO".failure
}


//   def findById(id: Long): Option[User] = {
//     val ouser = DB.withConnection { implicit c =>
//       SQL(
//         """
//         select id, email, username, fullname, last_login, active, email_validated
//         from users
//         where id = {id};
//         """
//       ) on (
//         'id -> id
//       ) as (parser.singleOpt)
//     }
// 
//     for {
//       user <- ouser
//     } yield user.withLinkedAccounts(LinkedAccount.forUser(user.id))
//   }
// 
//   def find(): List[User] = {
//     val users = DB.withConnection { implicit c =>
//       SQL( """ select id, email, username, fullname, last_login, active, email_validated from users; """ )
//       .as (parser *)
//     }
// 
//     for {
//       user <- users
//     } yield user.withLinkedAccounts(LinkedAccount.forUser(user.id))
//   }
// 
//   def findByEmail(email: String): Option[User] = {
//     val user = DB.withConnection { implicit c =>
//       val result: List[User] =
//         SQL(
//           """
//           select id, email, username, fullname, last_login, active, email_validated
//           from users
//           where email = {email};
//           """
//         ) on (
//           "email" -> email
//         ) as (parser *)
//       result.headOption // TODO: insure only one user exists w/given email
//     }
// 
//     user.map{u=>{
//       val accs = LinkedAccount.forUser(u.id)
//       u.copy(linkedAccounts=accs)
//     }}
//   }


  //   def existsByAuthUserIdentity(identity: AuthUserIdentity): Boolean = {
  //   private def getAuthUserFind(identity: AuthUserIdentity): ExpressionList[User] = {
  //   def findByAuthUserIdentity(identity: AuthUserIdentity): User = {
  //   def findByUsernamePasswordIdentity(identity: UsernamePasswordAuthUser): User = {
  //   private def getUsernamePasswordAuthUserFind(identity: UsernamePasswordAuthUser): ExpressionList[User] = {
  //   def merge(oldUser: AuthUser, newUser: AuthUser) {
  //   def addLinkedAccount(oldUser: AuthUser, newUser: AuthUser) {
  //   def setLastLoginDate(knownUser: AuthUser) {
  //   private def getEmailUserFind(email: String): ExpressionList[User] = {
}



case class User(
  id              : Long,
  email           : Option[String],
  username        : String,
  fullname        : Option[String],
  lastLogin       : Date,
  active          : Boolean,
  emailValidated  : Boolean,
  roles           : List[SecurityRole] = List(),
  linkedAccounts  : List[LinkedAccount] = List(),
  permissions     : List[UserPermission] = List()
) { 

  override def toString = "User("+id+", "+email+", "+username+")"

  // def addLinkedAccount(acc: LinkedAccount): User = {
  //   val linkedAcc = acc.copy(userId=id)
  //   this.copy(
  //     linkedAccounts=linkedAccounts ++ Seq(linkedAcc)
  //   )
  // }

//   def withLinkedAccounts(accs: List[LinkedAccount]): User = {
//     this.copy(linkedAccounts=accs)
//   }
// 
// 
//   def verifyEmail(token: TokenAction): Validation[String, User] = {
//     def update = {
//       DB.withConnection { implicit connection => {
//         SQL( 
//           """update users set email_validated=true where id={id} """
//         ).on (
//           'id -> id
//         ).executeUpdate()
//       }}
//     }
//     // is token correct type?
//     for {
//       t <- TokenAction.validation(token) // if t.isEmailVerification
//       val _ = update
//       user <- User.findById(id).toSuccess("error finding user w/given id after email verification")
//     } yield user
//   }
// 
//   // TODO: analyze and test how this will work w/multiple password login accounts (should that be allowed?)
//   //       if not allowed, how is it prohibited?
//   // TODO: verify that passResetInfo.email matches this.email
//   // create new linked account w/new password
//   // TODO write unit tests that assert proper token deletion after token-requiring operations
// 
// 
//   def changePassword(passResetInfo: PasswordResetInfo, token: TokenAction, createIfNoAccount: Boolean): Validation[String, Unit] = {
//     // TOOD: create database visualization of all entities
//     // println("this user: " + this)
//     // val allUsers = User.find()
//     // println("all users = " + allUsers.mkString(", "))
//     // val all = LinkedAccount.find()
//     // println("all accs = " + all.mkString(", "))
//     // val asdf = LinkedAccount.forUser(this.id)
//     // println("user accs = " + asdf.mkString(", "))
// 
//     val resetV = for {
//       acc <- (LinkedAccount.forUser(id) 
//         .filter(_.providerKey == AuthenticationMethod.UserPassword.method) 
//         .headOption.toSuccess[String]("error: should never reach here!")
//         .orElse(
//           if(createIfNoAccount) LinkedAccount.createForEmailPassword(this, passResetInfo)  else "new account creation prohibited".failure
//         )
//         .map(_.updateProviderUserId(passResetInfo.password)) // TODO hashed password!!!!
//       )
//       deleted <- token.delete()  // TODO should token be deleted even on failure? probably...
//     } yield deleted
// 
//     resetV map (_ => ())
//   }
//
//   def merge(otherUser: User) {
//     for (acc <- otherUser.linkedAccounts) {
//       this.linkedAccounts.add(LinkedAccount.create(acc))
//     }
//     otherUser.active = false
//     Ebean.save(Arrays.asList(Array(otherUser, this):_*))
//   }
//
//   def getProviders(): Set[String] = {
//     val providerKeys = new HashSet[String](linkedAccounts.size)
//     for (acc <- linkedAccounts) {
//       providerKeys.add(acc.providerKey)
//     }
//     providerKeys
//   }
//
//   def getAccountByProvider(providerKey: String): LinkedAccount = {
//     LinkedAccount.findByProviderKey(this, providerKey)
//   }
//
//   def changePassword(authUser: UsernamePasswordAuthUser, create: Boolean) {
//     var a = this.getAccountByProvider(authUser.getProvider)
//     if (a == null) {
//       if (create) {
//         a = LinkedAccount.create(authUser)
//         a.user = this
//       } else {
//         throw new RuntimeException("Account not enabled for password usage")
//       }
//     }
//     a.providerUserId = authUser.getHashedPassword
//     a.save()
//   }
//
}





//   def create(userInfo: UserRegistrationInfo):  Validation[String, User] = {
//     // val oid = DB.withConnection { implicit connection =>
//     //   SQL( """|
//     //     | insert into users(id, email, username, fullname, last_login, active, email_validated)
//     //     | values (
//     //     | 0, {email}, {username}, {fullname}, NOW(), false, false
//     //     | )
//     //     """.stripMargin
//     //   ).on (
//     //     'email -> userInfo.email,
//     //     'username -> userInfo.username,
//     //     'fullname -> userInfo.fullname
//     //   ).executeInsert()
//     val sql = SQL( """|
//         | insert into users(id, email, username, fullname, last_login, active, email_validated)
//         | values (
//         | 1, {email}, {username}, {fullname}, NOW(), false, false
//         | )
//         """.stripMargin
//       ).on (
//         'email -> userInfo.email,
//         'username -> userInfo.username,
//         'fullname -> userInfo.fullname
//       )
// 
//     // def execute1(getGeneratedKeys: Boolean = false)(implicit connection: java.sql.Connection): (java.sql.PreparedStatement, Int) = {
//     val oid = DB.withConnection { implicit connection => {
//       val statement = sql.getFilledStatement(connection, true)
// 
//       val generatedKeysParser = scalar[Long].singleOpt
//       val up = statement.executeUpdate()
//       val keys = statement.getGeneratedKeys()
// 
//       val asdf = generatedKeysParser(Sql.resultSetToStream(keys)) match {
//         case Success(a) => {
//           println("a: " + a)
//           a
//         }
//         case Error(e) => {
//           println("e?: " + e)
//           sys.error(e.toString)
//         }
//       }
//       asdf
//     }}
// 
//     //   (statement, { statement.executeUpdate() })
//     // }
//     // 
//     // Sql.as(generatedKeysParser, execute1(getGeneratedKeys = true)._1.getGeneratedKeys)
// 
// 
//     // user.linkedAccounts.foreach{ la => u.addLinkedAccount(la)}
//     //   userWithAccounts.linkedAccounts foreach {
//     //     la => LinkedAccount.create(la)
//     //   }
//     //   userWithAccounts.success
//     // }} getOrElse (
//     //   new Exception("createUser() failure").failure
//     // )
// 
// 
//     for {
//       id <- oid.toSuccess("user insert error")
//       user <- findById(id).toSuccess("no user with that id")
//     } yield user
// 
//     // "todo".failure
//   }
