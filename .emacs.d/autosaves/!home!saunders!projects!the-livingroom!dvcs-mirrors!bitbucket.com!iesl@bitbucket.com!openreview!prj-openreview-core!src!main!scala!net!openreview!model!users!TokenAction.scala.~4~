package net.openreview.model
package users


import scalaz.{Validation, Success, Failure}, Validation._, scalaz.syntax.validation._
import scalaz.syntax.std.option._
import java.net.URI
import org.joda.time.DateTime

case class TokenAction(
  id: Long,
  token: String,
  targetId: Long,
  ttype: TokenAction.TokenType,
  action: URI,
  created: DateTime,
  duration: Long
)  {
  def isNotExpired(): Boolean = {
    // val now = new Date()
    // val expires = new Date(created.getTime + (duration * 1000))
    // expires after now
    false
  }
  
  def delete(): Validation[String, Int] = {
    // val updated =
    //   DB.withConnection { implicit connection => {
    //                        SQL(
    //                          """ delete from token_action where id = {id}; """
    //                        ).on (
    //                          'id -> id
    //                        ).executeUpdate()
    //                      }}
    // if (updated==1) 1.success else "error deleting token".failure
    "TODO".failure
  }
}


object TokenAction {

  sealed trait TokenType 

  object TokenType {
    def fromString(s: String): TokenType = s match {
      case "EV" => EmailVerification
      case "PR" => PasswordReset
      case "IN" => AcceptInvite
      case tt @ _ => throw new RuntimeException("unknown TokenType: '" + tt + "'")
    }

    case object EmailVerification extends TokenType {
      override def toString = "EV"
    }
    case object PasswordReset extends TokenType {
      override def toString = "PR"
    }
    case object AcceptInvite extends TokenType {
      override def toString = "IN"
    }
  }

  def find(token: String): Option[TokenAction] = {
    // DB.withConnection { implicit c =>
    //   SQL(
    //     """ select %s from token_action where token = {token}; """.format(fields)
    //   ) on (
    //     'token -> token
    //   ) as (parseRow.singleOpt)
    // }
    sys.error("TODO")
  }

}




//   import TokenType._
// 
//   def validation(token: TokenAction): Validation[String, TokenAction] = {
//     if (token.isNotExpired) token.success else "token is expired".failure
//   }
// 
//   def createForEmailVerification(user: User, duration: Long): Validation[String, TokenAction] = {
//     create(user.id, EmailVerification, URI.create("/token/emailverify"), duration)
//   }
// 
//   def createForPasswordReset(user: User, duration: Long): Validation[String, TokenAction] = {
//     create(user.id, PasswordReset, URI.create("/token/passwordreset"), duration)
//   }
// 
//   def createForAcceptInvite(user: User, inviteeEmail:String, duration: Long): Validation[String, TokenAction] = {
//     create(user.id, AcceptInvite, URI.create("/token/acceptinvite"), duration)
//   }
// 
//   val fields = "id,  token,  target_user_id, type,  action, created,  duration"
// 
//   def create(targetId: Long, ttype: TokenAction.TokenType, action: URI, durationInSeconds:Long): Validation[String, TokenAction] = {
//     import java.util.UUID
// 
//     val oid = DB.withConnection { implicit connection =>
//       SQL( """|
//         insert into token_action(%s)
//         values (NULL, {token}, {targetId}, {type}, {action}, NOW(), {duration})
//         """.stripMargin.format(fields)
//       ).on (
//         'token -> UUID.randomUUID.toString,
//         'targetId -> targetId,
//         'type -> ttype.toString,
//         'action -> action.toString,
//         'duration -> durationInSeconds
//       ).executeInsert()
//     }
// 
//     for {
//       id <- oid.toSuccess("token action insert error")
//       token <- findById(id, ttype).toSuccess("no token with that id")
//     } yield token
//     
//   }
// 
//   val parseRow = {
//     get[Pk[Long]]("id") ~
//     get[String]("token") ~
//     get[Long]("target_user_id") ~
//     get[String]("type") ~
//     get[String]("action") ~
//     get[Date]("created") ~
//     get[Long]("duration") map {
//       case (
//         id ~
//         token ~
//         targetId ~
//         ttype ~
//         action ~ 
//         created ~
//         duration
//       ) => TokenAction(id.get, token, targetId, TokenAction.TokenType.fromString(ttype), URI.create(action), created, duration)
//     }
//   }
// 
//   def findById(id: Long, ttype: TokenType): Option[TokenAction] = {
//     DB.withConnection { implicit c =>
//       SQL(
//         """
//         select %s
//         from token_action
//         where id = {id} AND type={ttype};
//         """.format(fields)
//       ) on (
//         "id" -> id,
//         'ttype -> ttype.toString
//       ) as (parseRow.singleOpt)
//     }
//   }



//   def forUserId(id: Long, ttype: TokenType): List[TokenAction] = {
//     DB.withConnection { implicit c =>
//       SQL(
//         """
//         select %s
//         from token_action
//         where target_user_id = {targetUserId} AND type={ttype};
//         """.format(fields)
//       ) on (
//         'targetUserId -> id, 
//         'ttype -> ttype.toString
//       ) as (parseRow *)
//     }
//   }
// 
// }
// 
// 
