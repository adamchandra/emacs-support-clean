package lib.core


 
import play.api.Play.current
import play.api.db.DB
import play.api.test.Helpers._
import play.api.test._
 
import anorm._
import anorm.SqlParser._
import java.util.Date

import org.specs2.mutable
import org.specs2.mutable._

class DBEvolutionsTest extends mutable.Specification {

//   "Evolutions" should {
//     "be applied without errors" in {
//       running(FakeApplication(
//         additionalConfiguration = inMemoryDatabase(),
//         withoutPlugins = Seq("securesocial.core.providers.GoogleProvider")
//       )) {
//         evolutionFor("default")
//         val asdf = DB.withConnection {
//           implicit connection =>
//             SQL("select 'hey there!'").execute()
//         }
//         println("asdf: " + asdf)
//       }
//       success
//     }
//   }

  // TODO: move this to more general utility class
  def runInApp(b: => org.specs2.execute.Result): org.specs2.execute.Result = {
    running(FakeApplication(
      additionalConfiguration = inMemoryDatabase(),
      withoutPlugins = Seq(
        "securesocial.core.providers.GoogleProvider", 
        "service.InMemoryUserService", 
        "securesocial.core.providers.UsernamePasswordProvider")
    )) {
      evolutionFor("default")
      b
    }
  }



  import scalaz.Validation, Validation._, scalaz.syntax.validation._


  def createUser(user: User):  Validation[Exception, User] = {
    DB.withTransaction { implicit connection =>
      SQL( """|
        | insert into users(id, email, username, fullname, last_login, active, email_validated) 
        | values (
        | 0, {email}, {username}, {fullname}, NOW(), false, false
        | )
        """.stripMargin
      ).on (
        'email -> user.email,
        'username -> user.username,
        'fullname -> user.fullname
      ).executeUpdate()

      findUserByEmail(user.email) map (
        _.success
      ) getOrElse (
        new Exception("createUser() failure").failure
      )

    }
  }


  def findUserByEmail(email: String): Option[User] = {
    val simple = { 
      get[Pk[Long]]("id") ~ 
      get[String]("email") ~ 
      get[String]("username") ~ 
      get[Option[String]]("fullname") ~ 
      get[Date]("last_login") ~ 
      get[Boolean]("active") ~ 
      get[Boolean]("email_validated") map {
        case (
          id ~ 
          email ~ 
          username ~ 
          fullname ~ 
          last_login ~ 
          active ~ 
          email_validated
        ) => User(id.get, email, username, fullname, last_login, active, email_validated)
      }
    }

    DB.withConnection { implicit c =>
      val result: List[User] = 
        SQL(
          """
          select id, email, username, fullname, last_login, active, email_validated 
          from users
          where email = {email};
          """
        ) on (
          "email" -> email
        ) as (simple *)
      result.headOption
    }
  }


  def createLinkedAccount(linkedAccount: LinkedAccount): LinkedAccount = {
    DB.withConnection { implicit connection =>
      SQL( """|
        | insert into linked_account(id, user_id, provider_user_id, provider_key) 
        | values (
        | 0, {userId}, {providerUserId}, {providerKey}
        | )
        """.stripMargin
      ).on (
        'userId -> linkedAccount.userId,
        'providerUserId -> linkedAccount.providerUserId,
        'providerKey -> linkedAccount.providerKey
      ).executeUpdate()

      // TODO: this should fetch the value rather than just returning the input
      linkedAccount
    }
  }


  object modelEntity {
    val newlyCreatedUser = User(
      0,
      "a@b.com",
      "myname",
      Some("My Fullname"),
      null, 
      false, 
      false
    )

    val linkedAccount = LinkedAccount(
      id             = 0, 
      userId           = newlyCreatedUser.id, 
      providerUserId = "users-provider-id", 
      providerKey    = "some-provider"
    )

  }



  "Linked accounts" should {
    "not be creatable w/o a linked user" in {
      import org.h2.jdbc.JdbcSQLException
      runInApp {
        createLinkedAccount(modelEntity.linkedAccount) must throwA[JdbcSQLException]
      }
    }

    "accept username/password for account" in {
      todo
    }

    "accept oauth2 credentials (google, etc.)" in {
      todo
    } 
 }


  "Users" should {

    "upon creation, always implicitly create a linked account" in {
      runInApp {
        val user = modelEntity.newlyCreatedUser.addLinkedAccount(modelEntity.linkedAccount)

        createUser(user)
        val user2 = findUserByEmail("a@b.com")

        user2 must not beNone 
        
        val accs = user2.get.linkedAccounts

        accs.length must_== 1

        accs.head.providerUserId must_== "users-provider-id"
      }
    }



    "be created and retrieved by email" in {
      runInApp {
        val user = modelEntity.newlyCreatedUser.addLinkedAccount(modelEntity.linkedAccount)
 
        createUser(user)
        val user2 = findUserByEmail("a@b.com")
        
        user2 must not beNone 

        user2.get.username must_== user.username

      }
    }



    "able to set passwords properly" in {
      runInApp {
        val user = User(
          0,
          "a@b.com",
          "myname",
          Some("My Fullname"),
          null, 
          false, 
          false
        )

        createUser(user)
        val user2 = findUserByEmail("a@b.com")
        
        user2 must not beNone 

        user2.get.username must_== user.username
      }
    }
  }

}

